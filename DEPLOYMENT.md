# Production Deployment Guide

This guide walks you through deploying the AI Watermark Remover platform to production.

## Prerequisites

- GitHub account (for code hosting)
- Cloudflare account (for R2 storage)
- Railway account (for backend deployment)
- Vercel account (for frontend deployment)
- RunPod or Vast.ai account (for GPU worker)

## Step 1: Cloudflare R2 Setup

### 1.1 Create R2 Bucket

1. Go to [Cloudflare Dashboard](https://dash.cloudflare.com/)
2. Navigate to **R2 Object Storage**
3. Click **Create bucket**
4. Name it (e.g., `ai-watermark-remover`)
5. Click **Create bucket**

### 1.2 Configure Public Access

1. Go to bucket **Settings**
2. Scroll to **Public Access**
3. Click **Connect Domain** or **Allow Access**
4. Note your public URL (e.g., `https://pub-xxx.r2.dev`)

### 1.3 Get API Credentials

1. Go to **R2 Overview**
2. Click **Manage R2 API Tokens**
3. Click **Create API Token**
4. Grant **Edit** permissions
5. Save these values:
   ```
   Account ID: <your-account-id>
   Access Key ID: <access-key>
   Secret Access Key: <secret-key>
   Endpoint: https://<account-id>.r2.cloudflarestorage.com
   ```

## Step 2: Backend Deployment (Railway)

### 2.1 Prepare Repository

```bash
git init
git add .
git commit -m "Initial commit"
git remote add origin <your-github-repo>
git push -u origin main
```

### 2.2 Deploy to Railway

1. Go to [Railway](https://railway.app)
2. Click **New Project**
3. Select **Deploy from GitHub repo**
4. Choose your repository
5. Click **Add variables** and set:

```bash
DATABASE_URL=<auto-generated-by-railway>
REDIS_URL=<auto-generated-by-railway>
S3_ENDPOINT_URL=https://<account-id>.r2.cloudflarestorage.com
AWS_ACCESS_KEY_ID=<your-r2-access-key>
AWS_SECRET_ACCESS_KEY=<your-r2-secret-key>
BUCKET_NAME=ai-watermark-remover
PUBLIC_URL_BASE=https://pub-xxx.r2.dev
```

### 2.3 Add PostgreSQL

1. In your Railway project, click **New**
2. Select **Database** → **PostgreSQL**
3. Railway will auto-link it to your service

### 2.4 Add Redis

1. Click **New**
2. Select **Database** → **Redis**
3. Railway will auto-link it

### 2.5 Configure Service

1. Go to your backend service **Settings**
2. Set **Root Directory** to `backend`
3. Set **Start Command** to `uvicorn main:app --host 0.0.0.0 --port $PORT`
4. Click **Deploy**

### 2.6 Get Backend URL

Once deployed, Railway will give you a URL like:
```
https://your-app.railway.app
```

Save this for the frontend configuration.

## Step 3: Worker Deployment (RunPod)

### 3.1 Build Docker Image

```bash
cd worker
docker build -t <your-dockerhub-username>/watermark-worker:latest .
docker push <your-dockerhub-username>/watermark-worker:latest
```

### 3.2 Deploy on RunPod

1. Go to [RunPod](https://www.runpod.io/)
2. Click **Deploy**
3. Select **GPU Pod**
4. Choose **RTX 4090** or **A100 40GB**
5. Select **Custom Docker Image**
6. Enter: `<your-dockerhub-username>/watermark-worker:latest`
7. Set **Container Disk** to 50GB
8. Add environment variables:

```bash
REDIS_URL=redis://<railway-redis-host>:6379/0
S3_ENDPOINT_URL=https://<account-id>.r2.cloudflarestorage.com
AWS_ACCESS_KEY_ID=<your-r2-access-key>
AWS_SECRET_ACCESS_KEY=<your-r2-secret-key>
BUCKET_NAME=ai-watermark-remover
```

9. Click **Deploy**

> **Note**: Get the Railway Redis external hostname from Railway dashboard → Redis → Connect → External URL

### 3.3 Verify Worker

1. SSH into the RunPod instance
2. Check logs:
   ```bash
   docker logs -f <container-id>
   ```
3. You should see: `celery@... ready`

## Step 4: Frontend Deployment (Vercel)

### 4.1 Deploy

1. Go to [Vercel](https://vercel.com)
2. Click **Add New** → **Project**
3. Import your GitHub repository
4. Set **Framework Preset** to **Next.js**
5. Set **Root Directory** to `frontend`
6. Add environment variable:

```bash
NEXT_PUBLIC_API_URL=https://your-app.railway.app
```

7. Click **Deploy**

### 4.2 Get Frontend URL

Vercel will give you a URL like:
```
https://your-app.vercel.app
```

## Step 5: Update CORS (Backend)

Go back to Railway → Backend → Variables and update:

```bash
ALLOWED_ORIGINS=https://your-app.vercel.app,http://localhost:3000
```

Then update `backend/main.py`:

```python
app.add_middleware(
    CORSMiddleware,
    allow_origins=os.getenv("ALLOWED_ORIGINS", "*").split(","),
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

Redeploy the backend.

## Step 6: Test End-to-End

1. Visit your Vercel URL
2. Upload a test video
3. Select quality (Fast or HQ)
4. Click "Remove Watermark"
5. Monitor the job status page
6. Verify the result downloads

## Monitoring & Maintenance

### Check Backend Logs
```bash
# In Railway dashboard
Backend Service → Deployments → View Logs
```

### Check Worker Status
```bash
# SSH to RunPod
docker logs -f <container-id>
```

### Monitor Costs

| Service       | Dashboard                              |
|---------------|----------------------------------------|
| Cloudflare R2 | cloudflare.com → R2 → Usage            |
| Railway       | railway.app → Project → Usage          |
| RunPod        | runpod.io → Billing                    |
| Vercel        | vercel.com → Project → Usage           |

## Scaling Considerations

### When to Scale

- **Backend**: Add more Railway instances when CPU > 80%
- **Worker**: Add more RunPod instances when queue depth > 100
- **Database**: Upgrade PostgreSQL when connections > 80

### Auto-Scaling Worker

Create multiple RunPod pods with the same Docker image and Redis URL. Celery will automatically distribute tasks.

## Cost Optimization

1. **RunPod**: Use **Spot Instances** (50% cheaper) for non-critical processing
2. **Railway**: Enable **Sleep on Idle** for development environments
3. **R2**: Set **Lifecycle Rules** to delete old videos after 7 days
4. **Vercel**: Use **Free Plan** for up to 100GB bandwidth/month

## Troubleshooting

### Backend not connecting to DB
- Check `DATABASE_URL` in Railway variables
- Ensure PostgreSQL is running

### Worker not processing jobs
- Check Redis connection from RunPod
- Verify GPU is available: `nvidia-smi`
- Check Celery logs

### Frontend can't reach backend
- Verify CORS is configured
- Check `NEXT_PUBLIC_API_URL` in Vercel

### Videos not uploading
- Check R2 bucket permissions
- Verify presigned URL expiration (default: 1 hour)

## Production Checklist

- [ ] R2 bucket created and public
- [ ] Railway backend deployed with PostgreSQL + Redis
- [ ] RunPod worker deployed with GPU
- [ ] Vercel frontend deployed
- [ ] CORS configured correctly
- [ ] Environment variables set in all services
- [ ] Test upload → process → download flow
- [ ] Monitor costs and usage
- [ ] Set up error tracking (Sentry)
- [ ] Configure backup for PostgreSQL

## Next Steps

Consider adding:
- Custom domain for Vercel frontend
- Authentication (Clerk, Auth0)
- Payment integration (Stripe)
- Email notifications (Resend, SendGrid)
- Analytics (PostHog, Mixpanel)
- Rate limiting (Redis)
